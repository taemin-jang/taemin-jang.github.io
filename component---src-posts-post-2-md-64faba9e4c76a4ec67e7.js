"use strict";(self.webpackChunktaemin_jang_github_io=self.webpackChunktaemin_jang_github_io||[]).push([[692],{9405:function(e,n,t){t.r(n);var r=t(1151),l=t(7294);function a(e){const n=Object.assign({h1:"h1",p:"p",pre:"pre",code:"code",h2:"h2",h3:"h3",img:"img",ul:"ul",li:"li"},(0,r.ah)(),e.components);return l.createElement(l.Fragment,null,l.createElement(n.h1,null,"콜백 함수?"),"\n",l.createElement(n.p,null,"콜백 함수란 다른 함수의 인자로 함수를 넘겨주고, 해당 함수 내에서 전달 받은 함수를 실행하는 것이다."),"\n",l.createElement(n.p,null,"주로 매개변수에 함수를 전달해 일회용으로 사용하기 때문에 함수의 이름을 명시하지 않는 익명 함수로 사용한다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},'let button = document.getElementById("button"); // 버튼 요소를 선택\r\n\r\n// 버튼에 클릭 이벤트 리스너를 추가\r\nbutton.addEventListener("click", function () {\r\n  // 콜백 함수\r\n  console.log("Button clicked!");\r\n});\r\n\r\n// ------------------------------------\r\n\r\nsetTimeout(() => {\r\n  console.log("Delayed for 1 second.");\r\n}, 1000);\r\n\r\n// ------------------------------------\r\nfunction callback() {\r\n  console.log("hi");\r\n}\r\n\r\nfunction print(callback) {\r\n  callback();\r\n}\n')),"\n",l.createElement(n.h2,null,"콜백 함수 주의점"),"\n",l.createElement(n.h3,null,"1. this를 사용한 콜백함수"),"\n",l.createElement(n.p,null,"콜백 함수 내에서 ",l.createElement(n.code,null,"this"),"를 사용하면 예상한대로 동작하지 않을 수 있다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},'let userData = {\r\n  signUp: "2021-4-06 12:00:00",\r\n  name: "Not Set",\r\n  setName: function (firstName, lastName) {\r\n    this.name = firstName + " " + lastName;\r\n  },\r\n};\r\n\r\nfunction getUserName(firstName, lastName, callback) {\r\n  callback(firstName, lastName);\r\n}\r\n\r\ngetUserName("홍", "길동", userData.setName);\r\n\r\nconsole.log("1: ", userData.name); // Not Set\r\nconsole.log("2: ", window.name); // 홍 길동\n')),"\n",l.createElement(n.p,null,"callback 함수의 this는 호출한 함수의 this를 따르게 된다."),"\n",l.createElement(n.p,null,"따라서 usetData.setName을 호출한 getUserName의 this를 따르게 되고 해당 함수는 전역에서 호출했기 때문에 this는 window를 가리키게 된다."),"\n",l.createElement("details",null,l.createElement("summary",null,"예"),l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},'// 해당 콜백함수는 userData.setName과 아무런 관계가 없는 함수 형태만 비슷한 독립적인 함수이다.\r\ngetUserName("홍", "길동", function (firstName, lastName) {\r\n  this.name = firstName + " " + lastName;\r\n});\n'))),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},'let userData = {\r\n  signUp: "2021-4-06 12:00:00",\r\n  name: "Not Set",\r\n  setName: function (firstName, lastName) {\r\n    this.name = firstName + " " + lastName;\r\n  },\r\n};\r\n\r\nuserData.setName("홍", "길동");\r\n\r\nconsole.log(userData.name); // 홍 길동\n')),"\n",l.createElement(n.p,null,"이 경우에는 setName 메소드를 userData라는 객체에서 호출했기 때문에 this는 userData를 가리키게 된다."),"\n",l.createElement(n.h3,null,"2. 콜백 지옥(Callback Hell)"),"\n",l.createElement(n.p,null,"비동기 호출이 자주 일어날 때 콜백 지옥이 발생한다."),"\n",l.createElement(n.p,null,"콜백 함수 호출이 중첩되어 복잡도가 높아지는 현상이다."),"\n",l.createElement(n.img,{src:"../images/callback_hell.png",alt:"Callback Hell"}),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-jsx"},'function add(x, callback) {\r\n  let sum = x + x;\r\n  console.log(sum);\r\n  callback(sum);\r\n}\r\n\r\nadd(2, function (result) {\r\n  add(result, function (result) {\r\n    add(result, function (result) {\r\n      console.log("finish!!");\r\n    });\r\n  });\r\n});\r\n\r\n// <output>\r\n// 4\r\n// 8\r\n// 16\r\n// finish!!\n')),"\n",l.createElement(n.h2,null,"this 해결 방법"),"\n",l.createElement(n.p,null,"콜백 함수의 this를 보호할 수 있도록 만들어줘야 한다."),"\n",l.createElement(n.h3,null,"1. call(), apply() 메서드 사용"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"\n",l.createElement(n.p,null,"call()"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-jsx"},'// call 메서드 사용\r\nlet userData = {\r\n  signUp: "2021-4-06 12:00:00",\r\n  name: "Not Set",\r\n  setName: function (firstName, lastName) {\r\n    this.name = firstName + " " + lastName;\r\n  },\r\n};\r\n\r\nfunction getUserName(firstName, lastName, callback, data) {\r\n  // userData를 받는 매개변수 data를 추가\r\n  callback.call(data, firstName, lastName); // data를 this로 사용\r\n}\r\n\r\ngetUserName("홍", "길동", userData.setName, userData); // userData를 인수로 전달\r\n\r\nconsole.log("1: ", userData.name); // 홍 길동\r\nconsole.log("2: ", window.name); // Not Set\n')),"\n"),"\n",l.createElement(n.li,null,"\n",l.createElement(n.p,null,"apply()"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-jsx"},'// apply 메서드 사용\r\nlet userData = {\r\n  signUp: "2021-4-06 12:00:00",\r\n  name: "Not Set",\r\n  setName: function (firstName, lastName) {\r\n    this.name = firstName + " " + lastName;\r\n  },\r\n};\r\n\r\nfunction getUserName(firstName, lastName, callback, data) {\r\n  // userData를 받는 매개변수 data를 추가\r\n  callback.apply(data, [firstName, lastName]); // data를 this로 사용하고 배열을 전달\r\n}\r\n\r\ngetUserName("홍", "길동", userData.setName, userData); // userData를 인수로 전달\r\n\r\nconsole.log("1: ", userData.name); // 홍 길동\r\nconsole.log("2: ", window.name); // Not Set\n')),"\n"),"\n"),"\n",l.createElement(n.p,null,"화살표 함수도 해결방안이 될 수 있지만 현재 예시에서는 객체 메소드로 화살표 함수가 사용되기 때문에 똑같이 전역을 가리킨다."),"\n",l.createElement(n.h3,null,"2. Promise 사용"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-jsx"},'function add(x) {\r\n  return new Promise((resolve, reject) => {\r\n    let sum = x + x;\r\n    console.log(sum);\r\n    resolve(sum);\r\n  });\r\n}\r\n\r\nadd(2).then((result) => {\r\n  add(result).then((result) => {\r\n    add(result).then((result) => {\r\n      console.log("finish!!");\r\n    });\r\n  });\r\n});\r\n\r\n// <output>\r\n// 4\r\n// 8\r\n// 16\r\n// finish!!\n')),"\n",l.createElement(n.p,null,"하지만 promise도 결국 콜백지옥처럼 들여쓰기로 인해 이해하기 쉽지 않다. ⇒ Promise Hell"),"\n",l.createElement(n.p,null,"return을 사용하면 Promise Hell을 탈출 할 수 있다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-jsx"},'function add(x) {\r\n  return new Promise((resolve, reject) => {\r\n    let sum = x + x;\r\n    console.log(sum);\r\n    resolve(sum);\r\n  });\r\n}\r\n\r\nadd(2)\r\n  .then((result) => {\r\n    return add(result);\r\n  })\r\n  .then((result) => {\r\n    return add(result);\r\n  })\r\n  .then((result) => {\r\n    console.log("finish!!");\r\n  });\r\n\r\n// <output>\r\n// 4\r\n// 8\r\n// 16\r\n// finish!!\n')),"\n",l.createElement(n.h1,null,"Promise란?"),"\n",l.createElement(n.p,null,"프로미스는 자바스크립트 비동기 처리에 사용되는 객체이다."),"\n",l.createElement(n.h2,null,"Promise States"),"\n",l.createElement(n.img,{src:"../images/promise_state.png",alt:"Promise State"}),"\n",l.createElement(n.h3,null,"1. Pending (대기)"),"\n",l.createElement(n.p,null,"비동기 처리 로직이 아직 완료되지 않은 상태를 의미한다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-jsx"},"new Promise();\n")),"\n",l.createElement(n.h3,null,"2. Fulfilled (완료)"),"\n",l.createElement(n.p,null,"비동기 처리가 완료되어 프로미스가 결과 값을 반환해준 상태를 의미한다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-jsx"},"new Promise(function (resolve, reject) {\r\n  resolve();\r\n});\n")),"\n",l.createElement(n.p,null,"그리고 이행 상태가 되면 ",l.createElement(n.code,null,"then()"),"을 사용하여 처리 결과 값을 받을 수 있다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-jsx"},"function getData() {\r\n  return new Promise(function (resolve, reject) {\r\n    var data = 100;\r\n    resolve(data);\r\n  });\r\n}\r\n\r\n// resolve()의 결과 값 data를 resolvedData로 받음\r\ngetData().then(function (resolvedData) {\r\n  console.log(resolvedData); // 100\r\n});\n")),"\n",l.createElement(n.h3,null,"3. Rejected (실패)"),"\n",l.createElement(n.p,null,"비동기 처리가 실패하거나 오류가 발생한 상태를 의미한다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-jsx"},"new Promise(function (resolve, reject) {\r\n  reject();\r\n});\n")),"\n",l.createElement(n.p,null,"실패 상태가 되면 실패의 처리 결과 값을 ",l.createElement(n.code,null,"catch()"),"로 받을 수 있다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-jsx"},'function getData() {\r\n  return new Promise(function (resolve, reject) {\r\n    reject(new Error("Request is failed"));\r\n  });\r\n}\r\n\r\n// reject()의 결과 값 Error를 err에 받음\r\ngetData()\r\n  .then()\r\n  .catch(function (err) {\r\n    console.log(err); // Error: Request is failed\r\n  });\n')),"\n",l.createElement(n.h2,null,"Promise flow"),"\n",l.createElement(n.img,{src:"../images/promise_flow.png",alt:"Promise Flow"}),"\n",l.createElement(n.h2,null,"Promise Chaining"),"\n",l.createElement(n.p,null,"여러 개의 프로미스를 ",l.createElement(n.code,null,"then, catch, finally"),"로 연결하여 사용할 수 있다."),"\n",l.createElement(n.h3,null,"then"),"\n",l.createElement(n.p,null,"프로미스 객체를 반환 받고 해당 결과를 받거나 에러를 받을 수 있다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-jsx"},"promise.then(\r\n  function (result) {\r\n    /* 결과(result)를 다룹니다 */\r\n  },\r\n  function (error) {\r\n    /* 에러(error)를 다룹니다 */\r\n  }\r\n);\n")),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"then의 첫 번째 인수는 프로미스가 resolve 되었을 때 실행되는 함수로 실행 결과 값을 받아 처리"),"\n",l.createElement(n.li,null,"then의 두 번째 인수는 프로미스가 reject 되었을 때 실행되는 함수로 에러 값을 받아 처리"),"\n"),"\n",l.createElement(n.p,null,"하지만 주로 성공적(resolve)으로 처리 된 경우만 다루기 때문에 인수를 하나만 전달한다."),"\n",l.createElement(n.h3,null,"catch"),"\n",l.createElement(n.p,null,"에러가 발생한 경우, 즉 reject된 경우만 다루는 함수로 에러 처리할 때 사용한다."),"\n",l.createElement(n.p,null,l.createElement(n.code,null,".then(undefined, errorHandling)")," then에서 첫 번째 인자를 null로 전달하면 동일하게 작동한다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-jsx"},"promise.catch(function (error) {\r\n  /* 에러(error)를 다룹니다 */\r\n});\n")),"\n",l.createElement(n.p,null,"then으로 두 개의 인자를 받아서 처리하는 것보다 각각 하나의 역할로 처리하는 것이 코드 가독성에도 좋다."),"\n",l.createElement(n.h3,null,"finally"),"\n",l.createElement(n.p,null,"try - catch문에 finally 절이 있는 것과 같이, 프로미스에도 존재하며 resolve, reject 상관 없이 무조건 한번만 실행된다."),"\n",l.createElement(n.p,null,"주로 then, catch에 상관 없이 동일한 처리를 할 경우 사용된다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-jsx"},'new Promise((resolve, reject) => {\r\n  setTimeout(() => resolve("결과"), 2000)\r\n})\r\n  .finally(() => alert("프라미스가 준비되었습니다."))\r\n  .then(result => alert(result));\r\n\t.catch(err => alert(err));\n')),"\n",l.createElement(n.h1,null,"Async/Await"),"\n",l.createElement(n.p,null,"ES8(ECMAScript 2017)에서 간단하고 가독성 좋게 비동기 처리를 동기 처리처럼 동작하도록 구현하기 위해 도입되었다."),"\n",l.createElement(n.p,null,"async/await은 프로미스를 기반으로 동작하며, 프로미스의 후속 메서드인 then/catch/finally를 사용하지 않고 동기 처리처럼 사용할 수 있다."),"\n",l.createElement(n.h2,null,"async 함수"),"\n",l.createElement(n.p,null,"await 키워드는 반드시 async 함수 내부에서 사용해야 한다. async 함수는 async 키워드를 사용해서 정의하며 resolve하는 프로미스 객체를 반환한다."),"\n",l.createElement(n.h2,null,"await 키워드"),"\n",l.createElement(n.p,null,"프로미스가 settled 상태가 될 때까지 대기하다가 settled 상태가 되면 프로미스가 resolve한 처리 결과를 반환한다. await 키워드는 반드시 프로미스 앞에서 사용해야 한다!"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-jsx"},'const fetch = require("node-fetch");\r\n\r\nconst getGithubUserName = async (id) => {\r\n  const res = await fetch(`https://api.github.com/users/${id}`);\r\n  const { name } = await res.json();\r\n  console.log(name); // taemin-jang\r\n};\r\n\r\ngetGithubUserName("taemin-jang");\n')),"\n",l.createElement(n.h2,null,"에러 처리"),"\n",l.createElement(n.p,null,"이전 비동기 함수들은 try-catch문을 사용할 수 없었다."),"\n",l.createElement(n.p,null,"따라서 프로미스 객체로 반환되면 후속 메서드인 catch로 에러 처리를 할 수 있었는데 async/await은 try-catch문을 사용할 수 있다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-jsx"},'const fetch = require("node-fetch");\r\n\r\nconst getGithubUserName = async (id) => {\r\n  try {\r\n    const res = await fetch(`https://api.github.com/users/${id}`);\r\n    const { name } = await res.json();\r\n    console.log(name); // taemin-jang\r\n  } catch (err) {\r\n    console.log(err);\r\n  }\r\n};\r\n\r\ngetGithubUserName("taemin-jang");\n')),"\n",l.createElement(n.p,null,"따라서 async/await은 비동기 처리의 처리 순서가 보장되어야 하는 모든 프로미스에 사용하면 동기 처리처럼 동작시킬 수 있다."),"\n",l.createElement(n.h3,null,"마무리"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-jsx"},"setTimeout(() => console.log(1), 0);\r\n\r\nPromise.resolve()\r\n  .then(() => console.log(2))\r\n  .then(() => console.log(3));\n")))}n.default=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?l.createElement(n,e,l.createElement(a,e)):a(e)}},1151:function(e,n,t){t.d(n,{ah:function(){return a}});var r=t(7294);const l=r.createContext({});function a(e){const n=r.useContext(l);return r.useMemo((()=>"function"==typeof e?e(n):{...n,...e}),[n,e])}}}]);
//# sourceMappingURL=component---src-posts-post-2-md-64faba9e4c76a4ec67e7.js.map